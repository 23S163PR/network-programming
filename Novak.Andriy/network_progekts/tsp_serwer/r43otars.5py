using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace tsp_serwer
{
    class ChatServer
    {
        private TcpListener _server;
        private List<TcpClient> _clients;
        private const int MaxClientCount = 2;
        private const int ServerPort = 4567;
        private bool _stopNetwork;
      
        public ChatServer()
        {
            StartServer();
        }

        private void StartServer()
        {
            try
            {
                _clients = new List<TcpClient>();
                _stopNetwork = false;
                _server = new TcpListener(IPAddress.Any, ServerPort);
                _server.Start();
                var acceptThread = new Thread(AcceptClients);
                acceptThread.Start();
            }
            catch (Exception e) { }
        }

        public void AcceptClients()
        {
            while (true)
            {
                try
                {
                    var client =_server.AcceptTcpClient();
                    _clients.Add(client); 
                    var readThread = new Thread(ReceiveRun);
                    readThread.Start(client);
                }
                catch (Exception) { }
         
                if (_clients.Count <= MaxClientCount || _stopNetwork)
                {
                    break;
                }
            }
        }

        //read add broadcast message
        void ReceiveRun(object client)
        {
            var nClient = ((TcpClient) client);
            var message = new StringBuilder();
            while (nClient.Client.Connected)
            {
                var stream = nClient.GetStream();
                while (stream.DataAvailable)
                {
                    var buff = new byte[nClient.Available];
                    stream.ReadAsync(buff, 0, buff.Length);
                    message.Append(Encoding.ASCII.GetString(buff));
                    ClientStatus(nClient, message);  
                    Array.Clear(buff, 0, buff.Length);
                    stream.FlushAsync();
                }
                if (message.Length <= 0) continue;
                SendToClients(message.ToString());
                message.Clear();
            }
        }

        private void ClientStatus(TcpClient nClient, StringBuilder message)
        {
            if (message.ToString() == "404")
            {
                _clients.Remove(nClient);
                nClient.Client.Disconnect(false);
            }
        }

        //async send message
        void SendToClients(string text)
        {
            foreach (var client in _clients)
            {
                if (client == null) continue;
                var stream = client.GetStream();
                var buffer = Encoding.ASCII.GetBytes(text);
                stream.BeginWrite(buffer, 0, buffer.Length, AsyncSendCompleted, stream);
            }
        }

        // async send message calback
        private void AsyncSendCompleted(IAsyncResult ar)
        {
            var nets = (NetworkStream)ar.AsyncState;
            nets.EndWrite(ar);
        }

        public void StopServer()
        {
            if (_server == null)return;
            _server.Stop();
            _server = null;
            _stopNetwork = true;
            foreach (var client in _clients)
            {
                client.Close();
            }  
        }
    }
}
